<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wer wÃ¼rde eher...</title>
    <!-- Tailwind CSS CDN first -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Then Tailwind CSS configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {},
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .screen {
            display: none;
        }
        .screen.active {
            display: flex;
        }
        #timer-circle {
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            transition: stroke-dashoffset 0.1s linear;
        }
        .pie-chart-container {
            width: 90%;
            max-width: 400px;
            height: auto;
        }
        /* Style for active joker button */
        .joker-active {
            border: 3px solid #6366f1; /* Indigo-500 */
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.5); /* Glowing effect */
            animation: glowPulse 1.5s infinite alternate; /* Added glow animation */
        }
        /* Dark mode toggle button specific styles */
        #theme-toggle-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 60; /* Higher than other elements */
            padding: 0.5rem 0.75rem;
            background-color: #fff;
            border-radius: 9999px; /* full rounded */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        html.dark #theme-toggle-button {
            background-color: #1f2937; /* Darker background for dark mode */
            color: #d1d5db; /* Lighter text for dark mode */
        }

        /* --- NEW ANIMATIONS --- */

        /* Question Text Fade-in/Slide-up */
        #question-text {
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
        #question-text.fade-in {
            opacity: 1;
            transform: translateY(0);
        }

        /* Vote Button Pulse Effect */
        .vote-button-pulse {
            animation: pulseEffect 0.3s ease-out;
        }
        @keyframes pulseEffect {
            0% { transform: scale(1); box-shadow: none; }
            50% { transform: scale(1.03); box-shadow: 0 0 10px rgba(99, 102, 241, 0.7); } /* Indigo glow */
            100% { transform: scale(1); box-shadow: none; }
        }

        /* Joker Button Glow Pulse */
        @keyframes glowPulse {
            0% { box-shadow: 0 0 5px rgba(251, 191, 36, 0.5); } /* Yellow-500 subtle glow */
            100% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.8); }
        }

        /* Selected Emoji Highlight */
        .selected-emoji {
            background-color: #c7d2fe; /* indigo-200 */
            border: 2px solid #6366f1; /* indigo-500 */
            transform: scale(1.1);
            transition: transform 0.1s ease-out;
        }
        html.dark .selected-emoji {
            background-color: #4338ca; /* indigo-700 */
            border-color: #818cf8; /* indigo-400 */
        }
    </style>
</head>
<!-- Apply dark mode classes to body and app-container -->
<body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-100 flex items-center justify-center min-h-screen">

    <div id="app-container" class="w-full max-w-lg mx-auto p-4 md:p-6 bg-white rounded-2xl shadow-xl dark:bg-gray-800 dark:text-gray-100">

        <!-- Screen 1: Name & Lobby Code Input -->
        <div id="name-screen" class="screen active flex-col items-center gap-6">
            <h1 class="text-3xl font-bold text-gray-900 dark:text-gray-100">Wer wÃ¼rde eher...</h1>
            <div class="w-full flex flex-col gap-4">
                <div class="flex items-center gap-2"> <!-- New flex container for name input and avatar button -->
                    <input type="text" id="name-input" placeholder="Dein Name" class="flex-grow p-3 border border-gray-300 rounded-lg text-center focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100">
                    <button id="show-avatar-picker-button" class="p-2 bg-indigo-100 text-indigo-800 rounded-lg hover:bg-indigo-200 transition-colors dark:bg-indigo-900 dark:text-indigo-200 dark:hover:bg-indigo-800 text-2xl">ðŸ˜Š</button>
                </div>
                <input type="text" id="lobby-code-input" placeholder="Lobby-Code (optional)" class="w-full p-3 border border-gray-300 rounded-lg text-center uppercase focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100">
                
                <!-- Avatar Selection - initially hidden -->
                <div id="avatar-picker-container" class="w-full flex flex-col gap-2 hidden"> <!-- New container for toggling -->
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Dein Avatar:</label>
                    <div id="avatar-selection" class="grid grid-cols-6 gap-2 p-2 border border-gray-300 rounded-lg dark:border-gray-600 dark:bg-gray-700">
                        <!-- Emojis will be injected here by JS -->
                    </div>
                    <p class="text-center text-sm text-gray-500 dark:text-gray-400">Aktueller Avatar: <span id="selected-avatar" class="text-2xl">ðŸ‘¤</span></p>
                </div>
                <!-- End Avatar Selection -->

                <div class="grid grid-cols-2 gap-3">
                    <button id="create-lobby-button" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">Lobby erstellen</button>
                    <button id="join-lobby-button" class="w-full bg-green-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-600 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">Lobby beitreten</button>
                </div>
            </div>
            <p id="error-message" class="text-red-500 text-sm mt-2"></p>
        </div>

        <!-- Screen 2: Lobby -->
        <div id="lobby-screen" class="screen flex-col items-center gap-4">
            <div class="text-center">
                <h2 class="text-2xl font-bold text-gray-900 dark:text-gray-100">Lobby</h2>
                <div class="mt-2">
                    <span class="text-gray-500">Lobby-Code:</span>
                    <span id="lobby-code-display" class="font-bold text-2xl text-indigo-600 tracking-widest bg-gray-100 p-2 rounded-lg dark:bg-gray-700 dark:text-indigo-400"></span>
                </div>
            </div>
            <p class="text-gray-500">Warte auf weitere Spieler...</p>
            <div id="player-list" class="w-full bg-gray-50 p-4 rounded-lg min-h-[100px] space-y-2 dark:bg-gray-700">
                <!-- Player names will be injected here -->
            </div>
            <div id="host-controls" class="hidden w-full flex flex-col gap-3 mt-4">
                <div class="w-full">
                    <label for="category-select" class="block text-sm font-medium text-gray-700 mb-1 dark:text-gray-300">Kategorie</label>
                    <select id="category-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100">
                        <!-- Categories will be injected here -->
                    </select>
                </div>

                <!-- Custom Question Input -->
                <div id="custom-question-section" class="w-full flex flex-col gap-2 mt-2 hidden">
                    <label for="custom-question-input" class="block text-sm font-medium text-gray-700 mb-1 dark:text-gray-300">Eigene Frage hinzufÃ¼gen:</label>
                    <textarea id="custom-question-input" rows="2" placeholder="Wer wÃ¼rde eher... (max. 100 Zeichen)" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100"></textarea>
                    <button id="add-custom-question-button" class="w-full bg-purple-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-600 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">Frage hinzufÃ¼gen</button>
                    <div id="custom-questions-list" class="w-full bg-gray-50 p-3 rounded-lg mt-2 max-h-40 overflow-y-auto space-y-1 text-sm text-gray-700 dark:bg-gray-700 dark:text-gray-300">
                        <!-- Custom questions will be listed here -->
                    </div>
                </div>

                <button id="start-game-button" class="w-full bg-green-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-600 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">Spiel starten</button>
                <button id="reset-lobby-button" class="w-full bg-red-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-600 transition-transform transform hover:scale-105">Lobby auflÃ¶sen</button>
            </div>
            <p id="lobby-info-for-players" class="text-center text-gray-600 mt-4 dark:text-gray-400"></p>
            <button id="leave-lobby-button" class="mt-4 text-sm text-gray-500 hover:text-red-600 dark:text-gray-400 dark:hover:text-red-400">Lobby verlassen</button>
        </div>

        <!-- Screen 3: Game -->
        <div id="game-screen" class="screen flex-col items-center gap-4">
            <div class="relative w-24 h-24">
                <svg class="w-full h-full" viewBox="0 0 100 100">
                    <!-- Background circle -->
                    <circle class="stroke-gray-200 dark:stroke-gray-700" stroke-width="10" fill="transparent" r="45" cx="50" cy="50" />
                    <!-- Progress circle -->
                    <circle id="timer-circle" class="stroke-indigo-600 dark:stroke-indigo-400" stroke-width="10" stroke-linecap="round" fill="transparent" r="45" cx="50" cy="50"></circle>
                </svg>
                <span id="timer-text" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-3xl font-bold">20</span>
            </div>
            <p id="question-counter" class="text-sm font-semibold text-gray-500 dark:text-gray-400"></p>
            <h3 class="text-xl md:text-2xl font-semibold text-center mt-2" id="question-text"></h3>
            <div id="vote-options" class="w-full grid grid-cols-2 gap-3 mt-4">
                <!-- Vote buttons will be injected here -->
            </div>
            <p id="vote-info" class="text-center text-gray-500 mt-2 hidden dark:text-gray-400">Du hast bereits abgestimmt.</p>
            <img id="waiting-gif" src="https://media.tenor.com/nZQlCgAcIXQAAAAi/hood-irony-ghetto-smosh.gif" alt="Warten..." class="hidden w-48 h-48 mx-auto mt-4 rounded-lg">
            
            <!-- Double Vote Joker Button -->
            <button id="double-vote-joker-button" class="mt-4 w-full bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-yellow-600 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">
                Joker einsetzen (Doppelte Stimme!)
            </button>
        </div>

        <!-- Screen 4: Results -->
        <div id="results-screen" class="screen flex-col items-center gap-4">
            <p id="results-question-counter" class="text-sm font-semibold text-gray-500 dark:text-gray-400"></p>
            <h3 class="text-xl font-semibold text-center" id="results-question-text"></h3>
            <p class="text-gray-600 text-center mt-2 dark:text-gray-400">Ergebnisse der Abstimmung:</p>
            <div class="pie-chart-container">
                <canvas id="results-chart"></canvas>
            </div>
            <div id="results-host-controls" class="hidden w-full flex flex-col gap-3 mt-4">
                <button id="next-question-button" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-transform transform hover:scale-105">NÃ¤chste Frage</button>
                <button id="end-game-button" class="w-full bg-gray-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-600">Spiel beenden</button>
            </div>
            <p id="results-info-for-players" class="text-center text-gray-600 mt-4 dark:text-gray-400">Warte auf den Host fÃ¼r die nÃ¤chste Runde...</p>
        </div>
    </div>

    <!-- Theme Toggle Button -->
    <button id="theme-toggle-button" class="text-gray-800">
        ðŸŒ™
    </button>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, deleteDoc, arrayUnion, arrayRemove, deleteField, collection, query, orderBy, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyANV7_AKN8oZIpJ1JjIVuokO2Q6Gc-iN04",
            authDomain: "wer-wuerde-eher-70d61.firebaseapp.com",
            projectId: "wer-wuerde-eher-70d61",
            storageBucket: "wer-wuerde-eher-70d61.firebasestorage.app",
            messagingSenderId: "301727904397",
            appId: "1:301727904397:web:eec5b088e46425946b68c4",
        };

        const QUESTIONS = {
            'Standard': [
                "Wer wÃ¼rde eher einen Bungeesprung machen?", "Wer wÃ¼rde eher im Lotto gewinnen und alles fÃ¼r Unsinn ausgeben?", "Wer wÃ¼rde eher eine Reality-TV-Show gewinnen?", "Wer wÃ¼rde eher 2 Wochen ohne Handy auskommen?", "Wer wÃ¼rde eher einen Fremden auf der StraÃŸe umarmen?", "Wer wÃ¼rde eher ein Buch schreiben?", "Wer wÃ¼rde eher auf einen Berg klettern?", "Wer wÃ¼rde eher eine Weltreise alleine machen?", "Wer wÃ¼rde eher ein Haustier aus einem Tierheim adoptieren?", "Wer wÃ¼rde eher den ganzen Tag im Bett verbringen?", "Wer wÃ¼rde eher einen Witz erzÃ¤hlen, Ã¼ber den niemand lacht?", "Wer wÃ¼rde eher ein komplettes MenÃ¼ fÃ¼r alle kochen?", "Wer wÃ¼rde eher in einem Horrorfilm als erstes sterben?", "Wer wÃ¼rde eher eine neue Sprache in einem Monat lernen?", "Wer wÃ¼rde eher bei einer Talentshow mitmachen?", "Wer wÃ¼rde eher seinen Job kÃ¼ndigen, um Influencer zu werden?", "Wer wÃ¼rde eher barfuÃŸ durch die Stadt laufen?", "Wer wÃ¼rde eher ein Geheimnis fÃ¼r sich behalten?", "Wer wÃ¼rde eher einen Streit anfangen?", "Wer wÃ¼rde eher zu spÃ¤t zu seiner eigenen Hochzeit kommen?"
            ],
            'Peinlich': [
                "Wer wÃ¼rde eher in der Ã–ffentlichkeit stolpern und hinfallen?", "Wer wÃ¼rde eher den Namen seines Dates vergessen?", "Wer wÃ¼rde eher mit Toilettenpapier am Schuh herumlaufen?", "Wer wÃ¼rde eher in einer Bibliothek laut lachen?", "Wer wÃ¼rde eher die falsche Person kÃ¼ssen?", "Wer wÃ¼rde eher eine peinliche Nachricht an die falsche Person schicken?", "Wer wÃ¼rde eher beim Essen etwas auf sein weiÃŸes Hemd kleckern?", "Wer wÃ¼rde eher im Kino laut schnarchen?", "Wer wÃ¼rde eher gegen eine GlastÃ¼r laufen?", "Wer wÃ¼rde eher versuchen, eine automatische TÃ¼r aufzuschieben?", "Wer wÃ¼rde eher seinen Hosenstall offen lassen?", "Wer wÃ¼rde eher in einem wichtigen Meeting einen Lachanfall bekommen?", "Wer wÃ¼rde eher auf einer Party der Letzte sein, der geht?", "Wer wÃ¼rde eher ein schreckliches Geschenk machen?", "Wer wÃ¼rde eher im Supermarkt etwas fallen lassen und so tun, als wÃ¤re nichts passiert?", "Wer wÃ¼rde eher laut im Auto singen und an der Ampel erwischt werden?", "Wer wÃ¼rde eher mit dem Lehrer mit Vornamen reden?", "Wer wÃ¼rde eher im Restaurant das Essen zurÃ¼ckgehen lassen?", "Wer wÃ¼rde eher Ã¼ber seine eigenen FÃ¼ÃŸe fallen?", "Wer wÃ¼rde eher die Pointe eines Witzes verderben?"
            ],
            'Party': [
                "Wer wÃ¼rde eher auf den Tischen tanzen?", "Wer wÃ¼rde eher als erstes einschlafen?", "Wer wÃ¼rde eher den DJ bestechen, ein schlechtes Lied zu spielen?", "Wer wÃ¼rde eher mit einer Pflanze reden?", "Wer wÃ¼rde eher eine Polonaise starten?", "Wer wÃ¼rde eher alle GetrÃ¤nke mixen und probieren?", "Wer wÃ¼rde eher am nÃ¤chsten Morgen nichts mehr wissen?", "Wer wÃ¼rde eher Karaoke singen, obwohl er es nicht kann?", "Wer wÃ¼rde eher versuchen, mit dem Barkeeper zu flirten?", "Wer wÃ¼rde eher die Snacks alleine aufessen?", "Wer wÃ¼rde eher einen peinlichen Tanzmove auspacken?", "Wer wÃ¼rde eher mit dem Gastgeber Ã¼ber Politik diskutieren?", "Wer wÃ¼rde eher die Musik Ã¼bernehmen und alle nerven?", "Wer wÃ¼rde eher heimlich gehen, ohne sich zu verabschieden?", "Wer wÃ¼rde eher ein Trinkspiel vorschlagen?", "Wer wÃ¼rde eher am nÃ¤chsten Tag beim AufrÃ¤umen helfen?", "Wer wÃ¼rde eher eine Wette verlieren und etwas Dummes tun mÃ¼ssen?", "Wer wÃ¼rde eher Fotos von schlafenden Leuten machen?", "Wer wÃ¼rde eher eine Rede halten, obwohl niemand zuhÃ¶rt?", "Wer wÃ¼rde eher versuchen, einen Zaubertrick vorzufÃ¼hren und scheitern?"
            ]
        };

        // --- APPLICATION STATE ---
        let app, auth, db, isFirebaseReady = false;
        let currentUser = null;
        let localPlayerName = '';
        let localPlayerAvatar = 'ðŸ‘¤'; // Default avatar
        let currentLobbyId = null;
        let gameUnsubscribe = null;
        let currentChart = null;
        let timerInterval = null;
        const gameDuration = 20000; // 20 seconds in milliseconds

        // --- UI ELEMENTS ---
        const screens = { name: document.getElementById('name-screen'), lobby: document.getElementById('lobby-screen'), game: document.getElementById('game-screen'), results: document.getElementById('results-screen') };
        const nameInput = document.getElementById('name-input');
        const lobbyCodeInput = document.getElementById('lobby-code-input');
        const createLobbyButton = document.getElementById('create-lobby-button');
        const joinLobbyButton = document.getElementById('join-lobby-button');
        const nameScreenButtons = [createLobbyButton, joinLobbyButton];
        const errorMessage = document.getElementById('error-message');
        const playerList = document.getElementById('player-list');
        const hostControls = document.getElementById('host-controls');
        const startGameButton = document.getElementById('start-game-button');
        const resetLobbyButton = document.getElementById('reset-lobby-button');
        const questionText = document.getElementById('question-text');
        const questionCounter = document.getElementById('question-counter');
        const voteOptions = document.getElementById('vote-options');
        const voteInfo = document.getElementById('vote-info');
        const waitingGif = document.getElementById('waiting-gif');
        const resultsQuestionText = document.getElementById('results-question-text');
        const resultsQuestionCounter = document.getElementById('results-question-counter');
        const resultsChartCanvas = document.getElementById('results-chart');
        const resultsHostControls = document.getElementById('results-host-controls');
        const nextQuestionButton = document.getElementById('next-question-button');
        const endGameButton = document.getElementById('end-game-button');
        const categorySelect = document.getElementById('category-select');
        const lobbyInfoForPlayers = document.getElementById('lobby-info-for-players');
        const resultsInfoForPlayers = document.getElementById('results-info-for-players');
        const timerCircle = document.getElementById('timer-circle');
        const timerText = document.getElementById('timer-text');
        const lobbyCodeDisplay = document.getElementById('lobby-code-display');
        const leaveLobbyButton = document.getElementById('leave-lobby-button');

        // UI Elements for Custom Questions
        const customQuestionSection = document.getElementById('custom-question-section');
        const customQuestionInput = document.getElementById('custom-question-input');
        const addCustomQuestionButton = document.getElementById('add-custom-question-button');
        const customQuestionsList = document.getElementById('custom-questions-list');

        // UI Element for Double Vote Joker
        const doubleVoteJokerButton = document.getElementById('double-vote-joker-button');

        // UI Element for Theme Toggle
        const themeToggleButton = document.getElementById('theme-toggle-button');

        // UI Elements for Avatar Selection
        const showAvatarPickerButton = document.getElementById('show-avatar-picker-button'); // New button
        const avatarPickerContainer = document.getElementById('avatar-picker-container'); // Container to toggle visibility
        const avatarSelectionDiv = document.getElementById('avatar-selection');
        const selectedAvatarDisplay = document.getElementById('selected-avatar');
        const EMOJIS = ['ðŸ˜€', 'ðŸ˜Ž', 'ðŸ¥³', 'ðŸš€', 'ðŸŒŸ', 'ðŸ‘¾', 'ðŸ¤–', 'ðŸ‘»', 'ðŸ‘½', 'ðŸ™', 'ðŸ¦–', 'ðŸ¦„', 'ðŸ¦Š', 'ðŸ¼', 'ðŸ¦', 'ðŸ¦‰', 'ðŸ¦‹', 'ðŸŒ»', 'ðŸ•', 'ðŸŽ®', 'âš½', 'ðŸŽ¸', 'ðŸŽ¨', 'ðŸ“š', 'ðŸ’»', 'ðŸ’¡', 'ðŸ†', 'ðŸŽ‰'];


        // --- FUNCTIONS ---

        /**
         * Switches the active screen in the UI.
         * @param {string} screenName - The ID of the screen to activate (e.g., 'name', 'lobby', 'game', 'results').
         */
        function switchScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            if (screens[screenName]) screens[screenName].classList.add('active');
        }

        /**
         * Populates the category selection dropdown with available question categories.
         * Includes the "Benutzerdefiniert" (Custom) option.
         */
        function populateCategories() {
            categorySelect.innerHTML = '';
            Object.keys(QUESTIONS).forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                categorySelect.appendChild(option);
            });
            // Add custom category option
            const customOption = document.createElement('option');
            customOption.value = 'Benutzerdefiniert';
            customOption.textContent = 'Benutzerdefiniert';
            categorySelect.appendChild(customOption);
        }
            
        /**
         * Generates a random 5-character uppercase lobby code.
         * @returns {string} The generated lobby code.
         */
        function generateLobbyCode() {
            return Math.random().toString(36).substring(2, 7).toUpperCase();
        }

        /**
         * Validates the player's name input.
         * @returns {boolean} True if the input is valid, false otherwise.
         */
        function validateInputs() {
            const name = nameInput.value.trim();
            if (name.length < 2 || name.length > 15) {
                errorMessage.textContent = 'Name muss zwischen 2 und 15 Zeichen lang sein.';
                return false;
            }
            localPlayerName = name;
            errorMessage.textContent = '';
            return true;
        }

        /**
         * Initializes Firebase and sets up anonymous authentication.
         */
        async function initializeGame() {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                onAuthStateChanged(auth, user => {
                    currentUser = user;
                    if (user) {
                        isFirebaseReady = true;
                        // Enable buttons only after Firebase is ready AND name is entered (handled by input listener)
                        nameInput.dispatchEvent(new Event('input')); 
                    } else {
                        signInAnonymously(auth).catch(error => {
                            console.error("Anonymous sign-in failed:", error);
                            errorMessage.textContent = "Verbindung zum Server fehlgeschlagen.";
                        });
                    }
                });
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                errorMessage.textContent = "Verbindung zum Server konnte nicht hergestellt werden.";
            }
        }

        /**
         * Handles updates to the game state from Firebase.
         * @param {DocumentSnapshot} docSnapshot - The snapshot of the lobby document.
         */
        function handleGameStateUpdate(docSnapshot) {
            if (!docSnapshot.exists()) {
                // Lobby was dissolved or doesn't exist anymore
                if (currentLobbyId) { // Only show alert if we were actually in a lobby
                    alert("Die Lobby wurde vom Host aufgelÃ¶st oder existiert nicht mehr.");
                }
                resetLocalState();
                return;
            }

            const gameState = docSnapshot.data();
            // Ensure players object exists and is iterable
            const players = gameState.players || {};
            const playerIds = Object.keys(players);
            const isHost = gameState.hostId === currentUser?.uid; // Check currentUser before accessing uid
            const isPlayerInGame = playerIds.includes(currentUser?.uid);

            // If a player is no longer in the lobby (e.g., removed by host or left)
            if (!isPlayerInGame && currentLobbyId && currentUser && currentUser.uid !== gameState.hostId) {
                resetLocalState();
                alert("Du bist nicht mehr in der Lobby.");
                return;
            } else if (!isPlayerInGame && currentUser?.uid === gameState.hostId && playerIds.length === 0) {
                 // Host is alone and somehow left, or lobby was dissolved
                 resetLocalState();
                 return;
            }


            currentLobbyId = docSnapshot.id;
            lobbyCodeDisplay.textContent = currentLobbyId;

            if (gameState.status === 'lobby') {
                switchScreen('lobby');
                renderPlayerList(players, gameState.hostId);
                hostControls.classList.toggle('hidden', !isHost);
                startGameButton.disabled = playerIds.length < 2; // Host can only start with at least 2 players
                categorySelect.value = gameState.currentCategory;
                lobbyInfoForPlayers.textContent = isHost ? (playerIds.length < 2 ? 'Warte auf mindestens einen weiteren Spieler...' : '') : `Der Host (${players[gameState.hostId]?.name || 'Unbekannt'}) startet das Spiel.`;
                
                // Show/hide custom question section for host based on selected category
                if (isHost && gameState.currentCategory === 'Benutzerdefiniert') {
                    customQuestionSection.classList.remove('hidden');
                    renderCustomQuestionsList(gameState.customQuestions || []);
                    // Enable/disable add custom question button based on input
                    customQuestionInput.dispatchEvent(new Event('input'));
                } else {
                    customQuestionSection.classList.add('hidden');
                }

            } else { // For 'playing', 'results', 'game_over' statuses

                if (gameState.status === 'playing') {
                    switchScreen('game');
                    // Use currentQuestions if available (shuffled questions), otherwise fall back to QUESTIONS
                    const categoryQuestions = (gameState.currentCategory === 'Benutzerdefiniert' ? gameState.customQuestions : QUESTIONS[gameState.currentCategory]) || [];
                    const totalQuestions = categoryQuestions.length;
                    const currentIndex = gameState.currentQuestionIndex;
                    const question = categoryQuestions[currentIndex] || "Keine Frage mehr in dieser Kategorie.";
                    
                    // Apply question fade-in animation
                    questionText.classList.remove('fade-in'); // Reset animation
                    questionText.textContent = question;
                    // Force reflow to ensure animation restarts
                    void questionText.offsetWidth;
                    questionText.classList.add('fade-in');
                    
                    renderVoteOptions(players, gameState.votes || {}); // Pass empty object if votes is null/undefined
                    updateTimer(gameState.timerStartedAt);
                    
                    const hasVoted = gameState.votes && gameState.votes[currentUser.uid];
                    waitingGif.classList.toggle('hidden', !hasVoted);

                    // Update Double Vote Joker Button state
                    const currentPlayerState = players[currentUser.uid];
                    if (currentPlayerState) {
                        doubleVoteJokerButton.classList.toggle('hidden', hasVoted || currentPlayerState.jokerUsedThisGame);
                        doubleVoteJokerButton.classList.toggle('joker-active', currentPlayerState.jokerActiveForNextVote);
                        doubleVoteJokerButton.disabled = hasVoted || currentPlayerState.jokerUsedThisGame || currentPlayerState.jokerActiveForNextVote;
                    } else {
                        doubleVoteJokerButton.classList.add('hidden'); // Hide if player state not found
                    }

                } else if (gameState.status === 'results') {
                    if (timerInterval) clearInterval(timerInterval);
                    switchScreen('results');
                    waitingGif.classList.add('hidden');
                    // Use currentQuestions if available (shuffled questions), otherwise fall back to QUESTIONS
                    const categoryQuestions = (gameState.currentCategory === 'Benutzerdefiniert' ? gameState.customQuestions : QUESTIONS[gameState.currentCategory]) || [];
                    const totalQuestions = categoryQuestions.length;
                    const currentIndex = gameState.currentQuestionIndex;
                    const question = categoryQuestions[currentIndex] || "Letzte Frage wurde ausgewertet.";

                    resultsQuestionCounter.textContent = `Frage ${currentIndex + 1} / ${totalQuestions}`;
                    resultsQuestionText.textContent = question;
                    renderResultsChart(players, gameState.votes || {});
                    resultsHostControls.classList.toggle('hidden', !isHost);
                    resultsInfoForPlayers.textContent = isHost ? '' : `Warte auf den Host fÃ¼r die nÃ¤chste Runde...`;
                } else if (gameState.status === 'game_over') {
                    if (isHost) {
                        // Host initiates lobby dissolution after game over
                        dissolveLobby();
                    } else {
                        alert("Das Spiel ist beendet!");
                        resetLocalState();
                    }
                }
            }
        }

        /**
         * Renders the list of players in the lobby.
         * @param {Object} players - An object mapping player IDs to player names.
         * @param {string} hostId - The ID of the host player.
         */
        function renderPlayerList(players, hostId) {
            playerList.innerHTML = Object.entries(players).map(([id, p]) => 
                `<div class="p-2 bg-white rounded shadow-sm flex justify-between items-center dark:bg-gray-800 dark:text-gray-100">
                    <span class="flex items-center gap-2">
                        <span class="text-xl">${p.avatar || 'ðŸ‘¤'}</span> <!-- Display avatar -->
                        <span>${p.name}</span>
                    </span>
                    ${id === hostId ? '<span class="text-xs font-bold text-indigo-500 dark:text-indigo-400">HOST</span>' : ''}
                </div>`
            ).join('');
        }

        /**
         * Renders the voting options for the current question.
         * @param {Object} players - An object mapping player IDs to player names.
         * @param {Object} votes - An object mapping voter IDs to vote objects ({targetId: string, isDouble: boolean}).
         */
        function renderVoteOptions(players, votes) {
            voteOptions.innerHTML = '';
            const hasVoted = votes && votes[currentUser.uid];
            voteInfo.style.display = hasVoted ? 'block' : 'none';

            // Convert players object to an array for consistent iteration
            const playerArray = Object.entries(players);

            // Dynamically adjust grid columns based on number of players
            voteOptions.className = `w-full grid gap-3 mt-4 ${playerArray.length <= 2 ? 'grid-cols-1' : 'grid-cols-2'}`;

            playerArray.forEach(([playerId, playerData]) => {
                const button = document.createElement('button');
                button.textContent = playerData.name;
                button.dataset.voteFor = playerId;
                button.disabled = hasVoted; // Disable if already voted
                button.className = `p-3 rounded-lg font-semibold transition-transform transform ${
                    hasVoted ? 'bg-gray-300 text-gray-500 cursor-not-allowed dark:bg-gray-600 dark:text-gray-400' : 'bg-indigo-100 text-indigo-800 hover:bg-indigo-200 hover:scale-105 dark:bg-indigo-900 dark:text-indigo-200 dark:hover:bg-indigo-800'
                }`;
                button.addEventListener('click', handleVote);
                voteOptions.appendChild(button);
            });
        }

        /**
         * Renders the results of the current question as a pie chart.
         * @param {Object} players - An object mapping player IDs to player names.
         * @param {Object} votes - An object mapping voter IDs to vote objects ({targetId: string, isDouble: boolean}).
         */
        function renderResultsChart(players, votes) {
            const voteCounts = {};
            // Initialize vote counts for all players
            Object.values(players).forEach(p => voteCounts[p.name] = 0);

            // Count votes, considering double votes
            Object.values(votes).forEach(vote => {
                const votedForId = vote.targetId;
                const voteWeight = vote.isDouble ? 2 : 1;
                if (players[votedForId]) {
                    voteCounts[players[votedForId].name] += voteWeight;
                }
            });

            const labels = Object.keys(voteCounts);
            const data = Object.values(voteCounts);

            if (currentChart) currentChart.destroy();
            
            const textColor = document.documentElement.classList.contains('dark') ? '#d1d5db' : '#1F2937'; // Dynamic text color
            const borderColor = document.documentElement.classList.contains('dark') ? '#374151' : '#ffffff'; // Dynamic border color

            currentChart = new Chart(resultsChartCanvas, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Stimmen',
                        data: data,
                        backgroundColor: ['#818cf8', '#a78bfa', '#f472b6', '#fb923c', '#facc15', '#4ade80', '#2dd4bf', '#60a5fa'],
                        borderColor: borderColor,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: true,
                    plugins: {
                        legend: { position: 'top', labels: { color: textColor } },
                        tooltip: { callbacks: { label: ctx => `${ctx.label || ''}: ${ctx.parsed || 0} Stimme(n)` } }
                    }
                }
            });
        }
            
        /**
         * Sets the progress of the SVG timer circle.
         * @param {number} percent - The percentage of the circle to fill (0 to 1).
         */
        function setCircleProgress(percent) {
            const radius = timerCircle.r.baseVal.value;
            const circumference = radius * 2 * Math.PI;
            timerCircle.style.strokeDasharray = `${circumference} ${circumference}`;
            const offset = circumference - percent * circumference;
            timerCircle.style.strokeDashoffset = offset;
        }

        /**
         * Updates the countdown timer display and SVG circle.
         * @param {Timestamp} timerStartedAt - Firebase timestamp when the timer started.
         */
        function updateTimer(timerStartedAt) {
            if (timerInterval) clearInterval(timerInterval);
            if (!timerStartedAt) {
                timerText.textContent = '20';
                setCircleProgress(1); // Full circle
                return;
            }

            const startTime = timerStartedAt.toDate().getTime();

            timerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remainingSeconds = Math.max(0, Math.ceil((gameDuration - elapsed) / 1000));
                timerText.textContent = remainingSeconds;
                const progress = Math.max(0, (gameDuration - elapsed) / gameDuration);
                setCircleProgress(progress);
                if (elapsed >= gameDuration) {
                    clearInterval(timerInterval);
                    waitingGif.classList.add('hidden');
                }
            }, 100);
        }

        /**
         * Handles a player's vote for a question.
         * @param {Event} event - The click event from the vote button.
         */
        async function handleVote(event) {
            if (!isFirebaseReady || !currentUser || !currentLobbyId) return;
            const votedForId = event.target.dataset.voteFor;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);

            try {
                const gameDoc = await getDoc(gameDocRef);
                if (!gameDoc.exists()) return;
                const gameState = gameDoc.data();
                const currentPlayerState = gameState.players[currentUser.uid];

                if (!currentPlayerState) {
                    console.error("Current player state not found.");
                    return;
                }

                const isDoubleVote = currentPlayerState.jokerActiveForNextVote;

                const voteData = {
                    targetId: votedForId,
                    isDouble: isDoubleVote
                };

                // Update vote and joker status in a single batch for atomicity
                const updates = {
                    [`votes.${currentUser.uid}`]: voteData
                };

                if (isDoubleVote) {
                    updates[`players.${currentUser.uid}.jokerActiveForNextVote`] = false;
                    updates[`players.${currentUser.uid}.jokerUsedThisGame`] = true;
                }

                await updateDoc(gameDocRef, updates);

                // Add pulse animation to the clicked button
                event.target.classList.add('vote-button-pulse');
                setTimeout(() => {
                    event.target.classList.remove('vote-button-pulse');
                }, 300); // Match animation duration

            } catch (error) {
                console.error("Error casting vote:", error);
                errorMessage.textContent = "Fehler beim Abstimmen. Bitte versuche es erneut.";
            }
        }
            
        /**
         * Dissolves the current lobby (deletes it from Firebase). Only callable by host.
         */
        async function dissolveLobby() {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            try {
                // Before deleting, check if current user is indeed the host
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists() && docSnap.data().hostId === currentUser.uid) {
                    await deleteDoc(gameDocRef);
                    // handleGameStateUpdate will catch the !docSnapshot.exists() and reset state
                } else {
                    console.warn("Attempted to dissolve lobby without being the host or lobby not found.");
                    // If not host, just reset local state to leave the lobby
                    resetLocalState();
                }
            } catch(error) {
                console.error("Error dissolving lobby:", error);
                errorMessage.textContent = "Fehler beim AuflÃ¶sen der Lobby.";
                resetLocalState(); // Attempt to reset even on error
            }
        }
            
        /**
         * Resets the local application state to the initial name input screen.
         * Clears any active subscriptions or intervals.
         */
        function resetLocalState() {
            if (gameUnsubscribe) {
                gameUnsubscribe();
                gameUnsubscribe = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            localPlayerName = '';
            localPlayerAvatar = 'ðŸ‘¤'; // Reset avatar to default
            selectedAvatarDisplay.textContent = localPlayerAvatar; // Update display
            // Remove selected-emoji class from all emojis
            avatarSelectionDiv.querySelectorAll('.selected-emoji').forEach(el => el.classList.remove('selected-emoji'));
            // Add selected-emoji class to the default avatar
            avatarSelectionDiv.querySelector(`span[data-emoji="${localPlayerAvatar}"]`)?.classList.add('selected-emoji'); // Use data-emoji for selection

            currentLobbyId = null;
            nameInput.value = '';
            lobbyCodeInput.value = '';
            errorMessage.textContent = '';
            waitingGif.classList.add('hidden');
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            customQuestionInput.value = ''; // Clear custom question input
            customQuestionsList.innerHTML = ''; // Clear custom questions list
            avatarPickerContainer.classList.add('hidden'); // Ensure avatar picker is hidden on reset
            switchScreen('name');
        }

        /**
         * Renders the list of custom questions for the host.
         * @param {string[]} questions - Array of custom questions.
         */
        function renderCustomQuestionsList(questions) {
            customQuestionsList.innerHTML = '';
            if (questions.length === 0) {
                customQuestionsList.textContent = 'Noch keine eigenen Fragen hinzugefÃ¼gt.';
                return;
            }
            questions.forEach((q, index) => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center p-1 bg-white rounded shadow-sm dark:bg-gray-800 dark:text-gray-100';
                div.innerHTML = `
                    <span>${index + 1}. ${q}</span>
                    <button data-question="${q}" class="remove-question-button text-red-500 hover:text-red-700 text-lg">&times;</button>
                `;
                customQuestionsList.appendChild(div);
            });

            // Add event listeners for remove buttons
            customQuestionsList.querySelectorAll('.remove-question-button').forEach(button => {
                button.addEventListener('click', handleRemoveCustomQuestion);
            });
        }

        /**
         * Handles removing a custom question from the lobby.
         * @param {Event} event - The click event from the remove button.
         */
        async function handleRemoveCustomQuestion(event) {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const questionToRemove = event.target.dataset.question;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);

            try {
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists() && docSnap.data().hostId === currentUser.uid) {
                    await updateDoc(gameDocRef, {
                        customQuestions: arrayRemove(questionToRemove)
                    });
                } else {
                    console.warn("Attempted to remove question without being the host.");
                }
            } catch (error) {
                console.error("Error removing custom question:", error);
                errorMessage.textContent = "Fehler beim Entfernen der Frage.";
            }
        }

        /**
         * Populates the avatar selection grid and handles selection.
         */
        function populateAvatarSelection() {
            avatarSelectionDiv.innerHTML = '';
            EMOJIS.forEach(emoji => {
                const span = document.createElement('span');
                span.textContent = emoji;
                span.dataset.emoji = emoji; // Store emoji in a data attribute
                span.className = 'cursor-pointer text-2xl p-1 rounded-md hover:bg-indigo-100 dark:hover:bg-indigo-900 transition-colors flex items-center justify-center';
                
                if (emoji === localPlayerAvatar) {
                    span.classList.add('selected-emoji');
                }

                span.addEventListener('click', () => {
                    // Remove highlight from previously selected emoji
                    const currentlySelected = avatarSelectionDiv.querySelector('.selected-emoji');
                    if (currentlySelected) {
                        currentlySelected.classList.remove('selected-emoji');
                    }

                    localPlayerAvatar = emoji;
                    selectedAvatarDisplay.textContent = emoji;
                    span.classList.add('selected-emoji'); // Add highlight to newly selected
                });
                avatarSelectionDiv.appendChild(span);
            });
            selectedAvatarDisplay.textContent = localPlayerAvatar; // Ensure initial display is correct
        }


        // --- EVENT LISTENERS ---

        // Enable/disable buttons based on name input
        nameInput.addEventListener('input', () => {
            const nameIsValid = nameInput.value.trim().length >= 2 && nameInput.value.trim().length <= 15;
            createLobbyButton.disabled = !nameIsValid || !isFirebaseReady;
            joinLobbyButton.disabled = !nameIsValid || !isFirebaseReady; 
            if (!nameIsValid) {
                errorMessage.textContent = 'Name muss zwischen 2 und 15 Zeichen lang sein.';
            } else {
                errorMessage.textContent = '';
            }
        });

        createLobbyButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !validateInputs()) return;
            
            const newLobbyId = generateLobbyCode();
            currentLobbyId = newLobbyId;
            const gameDocRef = doc(db, "lobbies", newLobbyId);

            const newLobbyState = {
                hostId: currentUser.uid,
                status: 'lobby',
                players: { 
                    [currentUser.uid]: { 
                        name: localPlayerName,
                        avatar: localPlayerAvatar, // Add avatar to player state
                        jokerUsedThisGame: false, // Initialize joker status
                        jokerActiveForNextVote: false // Initialize joker status
                    } 
                },
                currentCategory: 'Standard',
                currentQuestionIndex: 0,
                votes: {},
                customQuestions: [], // Initialize custom questions array
                createdAt: serverTimestamp()
            };
            
            try {
                await setDoc(gameDocRef, newLobbyState);
                if (gameUnsubscribe) gameUnsubscribe();
                gameUnsubscribe = onSnapshot(gameDocRef, handleGameStateUpdate);
            } catch (error) {
                console.error("Error creating lobby:", error);
                errorMessage.textContent = "Fehler beim Erstellen der Lobby. Bitte versuche es erneut.";
            }
        });

        joinLobbyButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !validateInputs()) return;
            const lobbyId = lobbyCodeInput.value.trim().toUpperCase();
            if (!lobbyId) {
                errorMessage.textContent = "Bitte gib einen Lobby-Code ein.";
                return;
            }

            const gameDocRef = doc(db, "lobbies", lobbyId);
            try {
                const gameDoc = await getDoc(gameDocRef);
                if (!gameDoc.exists()) {
                    errorMessage.textContent = "Lobby nicht gefunden.";
                    return;
                }
                
                const gameState = gameDoc.data();
                // Check if lobby is full (e.g., max players 8, adjust as needed)
                if (Object.keys(gameState.players || {}).length >= 8) { // Example max players
                    errorMessage.textContent = "Lobby ist voll.";
                    return;
                }
                
                if (gameState.status !== 'lobby') {
                    errorMessage.textContent = "Diese Lobby ist nicht offen fÃ¼r neue Spieler.";
                    return;
                }

                currentLobbyId = lobbyId;
                const playerPath = `players.${currentUser.uid}`;
                // Add joker fields for joining player if they don't exist
                await updateDoc(gameDocRef, { 
                    [playerPath]: { 
                        name: localPlayerName,
                        avatar: localPlayerAvatar, // Add avatar to player state
                        jokerUsedThisGame: false,
                        jokerActiveForNextVote: false
                    } 
                });

                if (gameUnsubscribe) gameUnsubscribe();
                gameUnsubscribe = onSnapshot(gameDocRef, handleGameStateUpdate);

            } catch (error) {
                console.error("Error joining lobby:", error);
                errorMessage.textContent = "Fehler beim Beitreten zur Lobby. Stelle sicher, dass der Code korrekt ist.";
            }
        });
            
        leaveLobbyButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            
            try {
                const gameDoc = await getDoc(gameDocRef);
                if(gameDoc.exists()) {
                    if(gameDoc.data().hostId === currentUser.uid) {
                        // If host, dissolve the whole lobby
                        await dissolveLobby();
                    } else {
                        // If player, remove self from players list
                        const playerPath = `players.${currentUser.uid}`;
                        await updateDoc(gameDocRef, { [playerPath]: deleteField() });
                        resetLocalState(); // Reset local state immediately for players
                    }
                } else {
                    // Lobby already gone, just reset local state
                    resetLocalState();
                }
            } catch(error) {
                console.error("Error leaving lobby:", error);
                // Even if there's an error, try to reset locally
                resetLocalState();
            }
        });

        // --- HOST ACTIONS ---
        resetLobbyButton.addEventListener('click', dissolveLobby);

        startGameButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            const gameDoc = await getDoc(gameDocRef);
            
            if (!gameDoc.exists() || gameDoc.data().hostId !== currentUser.uid) {
                errorMessage.textContent = "Du bist nicht der Host dieser Lobby.";
                return;
            }

            const gameState = gameDoc.data();
            let questionsToUse;

            if (gameState.currentCategory === 'Benutzerdefiniert') {
                questionsToUse = gameState.customQuestions || [];
                if (questionsToUse.length === 0) {
                    alert("Die Kategorie 'Benutzerdefiniert' hat keine Fragen. Bitte fÃ¼ge Fragen hinzu oder wÃ¤hle eine andere Kategorie.");
                    return;
                }
            } else {
                questionsToUse = QUESTIONS[gameState.currentCategory] || [];
                if (questionsToUse.length === 0) {
                    alert("Diese Kategorie hat keine Fragen. Bitte wÃ¤hle eine andere.");
                    return;
                }
            }

            // Shuffle questions for a new game
            const shuffledQuestions = [...questionsToUse].sort(() => Math.random() - 0.5);

            // Reset joker status for all players at the start of a new game
            const playersToUpdate = {};
            for (const playerId in gameState.players) {
                playersToUpdate[`players.${playerId}.jokerUsedThisGame`] = false;
                playersToUpdate[`players.${playerId}.jokerActiveForNextVote`] = false;
            }

            await updateDoc(gameDocRef, {
                status: 'playing',
                currentQuestionIndex: 0,
                currentQuestions: shuffledQuestions, // Store shuffled questions
                votes: {},
                timerStartedAt: serverTimestamp(),
                ...playersToUpdate // Apply joker resets
            });
            
            // Auto-transition to results after gameDuration + small buffer
            setTimeout(async () => {
                const freshDoc = await getDoc(gameDocRef);
                // Only transition if still playing the same question and current user is host
                if (freshDoc.exists() && freshDoc.data().status === 'playing' && freshDoc.data().currentQuestionIndex === 0 && freshDoc.data().hostId === currentUser.uid) {
                        await updateDoc(gameDocRef, { status: 'results' });
                }
            }, gameDuration + 500); // 500ms buffer
        });
            
        categorySelect.addEventListener('change', async (e) => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const newCategory = e.target.value;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);

            const docSnap = await getDoc(gameDocRef);
            if (!docSnap.exists() || docSnap.data().hostId !== currentUser.uid) {
                errorMessage.textContent = "Nur der Host kann die Kategorie Ã¤ndern.";
                return;
            }

            await updateDoc(gameDocRef, { currentCategory: newCategory });
        });
            
        nextQuestionButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            const gameDoc = await getDoc(gameDocRef);

            if (!gameDoc.exists() || gameDoc.data().hostId !== currentUser.uid) {
                errorMessage.textContent = "Du bist nicht der Host dieser Lobby.";
                return;
            }

            const gameState = gameDoc.data();
            const currentQuestions = gameState.currentQuestions || []; // Use shuffled questions
            const nextIndex = gameState.currentQuestionIndex + 1;

            // Reset jokerActiveForNextVote for all players for the next question
            const playersToUpdate = {};
            for (const playerId in gameState.players) {
                playersToUpdate[`players.${playerId}.jokerActiveForNextVote`] = false;
            }

            if (nextIndex >= currentQuestions.length) {
                await updateDoc(gameDocRef, { status: 'game_over', ...playersToUpdate });
            } else {
                await updateDoc(gameDocRef, {
                    status: 'playing',
                    currentQuestionIndex: nextIndex,
                    votes: {},
                    timerStartedAt: serverTimestamp(),
                    ...playersToUpdate // Apply jokerActiveForNextVote reset
                });
                
                // Auto-transition to results after gameDuration + small buffer
                setTimeout(async () => {
                    const freshDoc = await getDoc(gameDocRef);
                    // Only transition if still playing the same question and current user is host
                    if (freshDoc.exists() && freshDoc.data().status === 'playing' && freshDoc.data().currentQuestionIndex === nextIndex && freshDoc.data().hostId === currentUser.uid) {
                            await updateDoc(gameDocRef, { status: 'results' });
                    }
                }, gameDuration + 500); // 500ms buffer
            }
        });

        endGameButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            const docSnap = await getDoc(gameDocRef);

            if (!docSnap.exists() || docSnap.data().hostId !== currentUser.uid) {
                errorMessage.textContent = "Du bist nicht der Host dieser Lobby.";
                return;
            }
            await updateDoc(gameDocRef, { status: 'game_over' });
        });

        // --- CUSTOM QUESTION LOGIC ---
        customQuestionInput.addEventListener('input', () => {
            const questionText = customQuestionInput.value.trim();
            addCustomQuestionButton.disabled = questionText.length === 0 || questionText.length > 100;
        });

        addCustomQuestionButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const questionText = customQuestionInput.value.trim();

            if (questionText.length === 0 || questionText.length > 100) {
                alert("Bitte gib eine Frage zwischen 1 und 100 Zeichen ein.");
                return;
            }

            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            try {
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists() && docSnap.data().hostId === currentUser.uid) {
                    await updateDoc(gameDocRef, {
                        customQuestions: arrayUnion(questionText)
                    });
                    customQuestionInput.value = ''; // Clear input after adding
                } else {
                    alert("Du bist nicht der Host dieser Lobby und kannst keine Fragen hinzufÃ¼gen.");
                }
            } catch (error) {
                console.error("Error adding custom question:", error);
                alert("Fehler beim HinzufÃ¼gen der Frage. Bitte versuche es erneut.");
            }
        });

        // --- DOUBLE VOTE JOKER LOGIC ---
        doubleVoteJokerButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;

            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            try {
                const docSnap = await getDoc(gameDocRef);
                if (!docSnap.exists()) return;
                const gameState = docSnap.data();
                const currentPlayerState = gameState.players[currentUser.uid];

                if (!currentPlayerState) {
                    console.error("Current player state not found for joker activation.");
                    return;
                }

                if (currentPlayerState.jokerUsedThisGame) {
                    alert("Du hast deinen Joker fÃ¼r dieses Spiel bereits eingesetzt!");
                    return;
                }
                if (currentPlayerState.jokerActiveForNextVote) {
                    // Already active, perhaps toggle off? For now, just do nothing.
                    return;
                }
                
                // Activate joker for next vote
                await updateDoc(gameDocRef, {
                    [`players.${currentUser.uid}.jokerActiveForNextVote`]: true
                });

            } catch (error) {
                console.error("Error activating double vote joker:", error);
                errorMessage.textContent = "Fehler beim Aktivieren des Jokers. Bitte versuche es erneut.";
            }
        });

        // --- THEME TOGGLE LOGIC ---
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                themeToggleButton.textContent = 'â˜€ï¸'; // Sun icon for dark mode
            } else {
                document.documentElement.classList.remove('dark');
                themeToggleButton.textContent = 'ðŸŒ™'; // Moon icon for light mode
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        }

        // Apply theme on initial load
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            applyTheme(savedTheme);
        } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            // Default to system preference if no saved theme
            applyTheme('dark');
        } else {
            applyTheme('light'); // Default to light if no preference
        }

        themeToggleButton.addEventListener('click', toggleTheme);


        // --- INITIALIZATION ---
        populateCategories();
        populateAvatarSelection(); // Call this to set up the avatar selection
        initializeGame();

        // Event listener for the new show avatar picker button
        showAvatarPickerButton.addEventListener('click', () => {
            avatarPickerContainer.classList.toggle('hidden');
        });

    </script>
</body>
</html>
