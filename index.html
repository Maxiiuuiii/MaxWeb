<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wer würde eher...</title>
    <!-- Tailwind CSS CDN first -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Then Tailwind CSS configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {},
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .screen {
            display: none;
        }
        .screen.active {
            display: flex;
        }
        #timer-circle {
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            transition: stroke-dashoffset 0.1s linear;
        }
        .pie-chart-container {
            width: 90%;
            max-width: 400px;
            height: auto;
        }
        /* Style for active joker button */
        .joker-active {
            border: 3px solid #6366f1; /* Indigo-500 */
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.5); /* Glowing effect */
            animation: glowPulse 1.5s infinite alternate; /* Added glow animation */
        }
        /* Dark mode toggle button specific styles */
        #theme-toggle-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 60; /* Higher than other elements */
            padding: 0.5rem 0.75rem;
            background-color: #fff;
            border-radius: 9999px; /* full rounded */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        html.dark #theme-toggle-button {
            background-color: #1f2937; /* Darker background for dark mode */
            color: #d1d5db; /* Lighter text for dark mode */
        }

        /* --- NEW ANIMATIONS --- */

        /* Question Text Fade-in/Slide-up */
        #question-text {
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
        #question-text.fade-in {
            opacity: 1;
            transform: translateY(0);
        }

        /* Vote Button Pulse Effect */
        .vote-button-pulse {
            animation: pulseEffect 0.3s ease-out;
        }
        @keyframes pulseEffect {
            0% { transform: scale(1); box-shadow: none; }
            50% { transform: scale(1.03); box-shadow: 0 0 10px rgba(99, 102, 241, 0.7); } /* Indigo glow */
            100% { transform: scale(1); box-shadow: none; }
        }

        /* Joker Button Glow Pulse */
        @keyframes glowPulse {
            0% { box-shadow: 0 0 5px rgba(251, 191, 36, 0.5); } /* Yellow-500 subtle glow */
            100% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.8); }
        }

        /* Selected Emoji Highlight */
        .selected-emoji {
            background-color: #c7d2fe; /* indigo-200 */
            border: 2px solid #6366f1; /* indigo-500 */
            transform: scale(1.1);
            transition: transform 0.1s ease-out;
        }
        html.dark .selected-emoji {
            background-color: #4338ca; /* indigo-700 */
            border-color: #818cf8; /* indigo-400 */
        }
    </style>
</head>
<!-- Apply dark mode classes to body and app-container -->
<body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-100 flex items-center justify-center min-h-screen">

    <div id="app-container" class="w-full max-w-lg mx-auto p-4 md:p-6 bg-white rounded-2xl shadow-xl dark:bg-gray-800 dark:text-gray-100">

        <!-- Screen 1: Name & Lobby Code Input -->
        <div id="name-screen" class="screen active flex-col items-center gap-6">
            <h1 class="text-3xl font-bold text-gray-900 dark:text-gray-100">Wer würde eher...</h1>
            <div class="w-full flex flex-col gap-4">
                <div class="flex items-center gap-2"> <!-- New flex container for name input and avatar button -->
                    <input type="text" id="name-input" placeholder="Dein Name" class="flex-grow p-3 border border-gray-300 rounded-lg text-center focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100">
                    <button id="show-avatar-picker-button" class="p-2 bg-indigo-100 text-indigo-800 rounded-lg hover:bg-indigo-200 transition-colors dark:bg-indigo-900 dark:text-indigo-200 dark:hover:bg-indigo-800 text-2xl">😊</button>
                </div>
                <input type="text" id="lobby-code-input" placeholder="Lobby-Code (optional)" class="w-full p-3 border border-gray-300 rounded-lg text-center uppercase focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100">
                
                <!-- Avatar Selection - initially hidden -->
                <div id="avatar-picker-container" class="w-full flex flex-col gap-2 hidden"> <!-- New container for toggling -->
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Dein Avatar:</label>
                    <div id="avatar-selection" class="grid grid-cols-6 gap-2 p-2 border border-gray-300 rounded-lg dark:border-gray-600 dark:bg-gray-700">
                        <!-- Emojis will be injected here by JS -->
                    </div>
                    <p class="text-center text-sm text-gray-500 dark:text-gray-400">Aktueller Avatar: <span id="selected-avatar" class="text-2xl">👤</span></p>
                </div>
                <!-- End Avatar Selection -->

                <div class="grid grid-cols-2 gap-3">
                    <button id="create-lobby-button" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">Lobby erstellen</button>
                    <button id="join-lobby-button" class="w-full bg-green-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-600 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">Lobby beitreten</button>
                </div>
            </div>
            <p id="error-message" class="text-red-500 text-sm mt-2"></p>
        </div>

        <!-- Screen 2: Lobby -->
        <div id="lobby-screen" class="screen flex-col items-center gap-4">
            <div class="text-center">
                <h2 class="text-2xl font-bold text-gray-900 dark:text-gray-100">Lobby</h2>
                <div class="mt-2">
                    <span class="text-gray-500">Lobby-Code:</span>
                    <span id="lobby-code-display" class="font-bold text-2xl text-indigo-600 tracking-widest bg-gray-100 p-2 rounded-lg dark:bg-gray-700 dark:text-indigo-400"></span>
                </div>
            </div>
            <p class="text-gray-500">Warte auf weitere Spieler...</p>
            <div id="player-list" class="w-full bg-gray-50 p-4 rounded-lg min-h-[100px] space-y-2 dark:bg-gray-700">
                <!-- Player names will be injected here -->
            </div>
            <div id="host-controls" class="hidden w-full flex flex-col gap-3 mt-4">
                <div class="w-full">
                    <label for="category-select" class="block text-sm font-medium text-gray-700 mb-1 dark:text-gray-300">Kategorie</label>
                    <select id="category-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100">
                        <!-- Categories will be injected here -->
                    </select>
                </div>

                <!-- Custom Question Input -->
                <div id="custom-question-section" class="w-full flex flex-col gap-2 mt-2 hidden">
                    <label for="custom-question-input" class="block text-sm font-medium text-gray-700 mb-1 dark:text-gray-300">Eigene Frage hinzufügen:</label>
                    <textarea id="custom-question-input" rows="2" placeholder="Wer würde eher... (max. 100 Zeichen)" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100"></textarea>
                    <button id="add-custom-question-button" class="w-full bg-purple-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-600 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">Frage hinzufügen</button>
                    <div id="custom-questions-list" class="w-full bg-gray-50 p-3 rounded-lg mt-2 max-h-40 overflow-y-auto space-y-1 text-sm text-gray-700 dark:bg-gray-700 dark:text-gray-300">
                        <!-- Custom questions will be listed here -->
                    </div>
                </div>

                <button id="start-game-button" class="w-full bg-green-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-600 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">Spiel starten</button>
                <button id="reset-lobby-button" class="w-full bg-red-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-600 transition-transform transform hover:scale-105">Lobby auflösen</button>
            </div>
            <p id="lobby-info-for-players" class="text-center text-gray-600 mt-4 dark:text-gray-400"></p>
            <button id="leave-lobby-button" class="mt-4 text-sm text-gray-500 hover:text-red-600 dark:text-gray-400 dark:hover:text-red-400">Lobby verlassen</button>
        </div>

        <!-- Screen 3: Game -->
        <div id="game-screen" class="screen flex-col items-center gap-4">
            <div class="relative w-24 h-24">
                <svg class="w-full h-full" viewBox="0 0 100 100">
                    <!-- Background circle -->
                    <circle class="stroke-gray-200 dark:stroke-gray-700" stroke-width="10" fill="transparent" r="45" cx="50" cy="50" />
                    <!-- Progress circle -->
                    <circle id="timer-circle" class="stroke-indigo-600 dark:stroke-indigo-400" stroke-width="10" stroke-linecap="round" fill="transparent" r="45" cx="50" cy="50"></circle>
                </svg>
                <span id="timer-text" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-3xl font-bold">20</span>
            </div>
            <p id="question-counter" class="text-sm font-semibold text-gray-500 dark:text-gray-400"></p>
            <h3 class="text-xl md:text-2xl font-semibold text-center mt-2" id="question-text"></h3>
            <div id="vote-options" class="w-full grid grid-cols-2 gap-3 mt-4">
                <!-- Vote buttons will be injected here -->
            </div>
            <p id="vote-info" class="text-center text-gray-500 mt-2 hidden dark:text-gray-400">Du hast bereits abgestimmt.</p>
            <img id="waiting-gif" src="https://media.tenor.com/nZQlCgAcIXQAAAAi/hood-irony-ghetto-smosh.gif" alt="Warten..." class="hidden w-48 h-48 mx-auto mt-4 rounded-lg">
            
            <!-- Double Vote Joker Button -->
            <button id="double-vote-joker-button" class="mt-4 w-full bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-yellow-600 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">
                Joker einsetzen (Doppelte Stimme!)
            </button>
        </div>

        <!-- Screen 4: Results -->
        <div id="results-screen" class="screen flex-col items-center gap-4">
            <p id="results-question-counter" class="text-sm font-semibold text-gray-500 dark:text-gray-400"></p>
            <h3 class="text-xl font-semibold text-center" id="results-question-text"></h3>
            <p class="text-gray-600 text-center mt-2 dark:text-gray-400">Ergebnisse der Abstimmung:</p>
            <div class="pie-chart-container">
                <canvas id="results-chart"></canvas>
            </div>
            <div id="results-host-controls" class="hidden w-full flex flex-col gap-3 mt-4">
                <button id="next-question-button" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-transform transform hover:scale-105">Nächste Frage</button>
                <button id="end-game-button" class="w-full bg-gray-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-600">Spiel beenden</button>
            </div>
            <p id="results-info-for-players" class="text-center text-gray-600 mt-4 dark:text-gray-400">Warte auf den Host für die nächste Runde...</p>
        </div>
    </div>

    <!-- Theme Toggle Button -->
    <button id="theme-toggle-button" class="text-gray-800">
        🌙
    </button>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, deleteDoc, arrayUnion, arrayRemove, deleteField, collection, query, orderBy, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyANV7_AKN8oZIpJ1JjIVuokO2Q6Gc-iN04",
            authDomain: "wer-wuerde-eher-70d61.firebaseapp.com",
            projectId: "wer-wuerde-eher-70d61",
            storageBucket: "wer-wuerde-eher-70d61.firebasestorage.app",
            messagingSenderId: "301727904397",
            appId: "1:301727904397:web:eec5b088e46425946b68c4",
        };

        const QUESTIONS = {
            'Standard': [
                "Wer würde eher einen Bungeesprung machen?", "Wer würde eher im Lotto gewinnen und alles für Unsinn ausgeben?", "Wer würde eher eine Reality-TV-Show gewinnen?", "Wer würde eher 2 Wochen ohne Handy auskommen?", "Wer würde eher einen Fremden auf der Straße umarmen?", "Wer würde eher ein Buch schreiben?", "Wer würde eher auf einen Berg klettern?", "Wer würde eher eine Weltreise alleine machen?", "Wer würde eher ein Haustier aus einem Tierheim adoptieren?", "Wer würde eher den ganzen Tag im Bett verbringen?", "Wer würde eher einen Witz erzählen, über den niemand lacht?", "Wer würde eher ein komplettes Menü für alle kochen?", "Wer würde eher in einem Horrorfilm als erstes sterben?", "Wer würde eher eine neue Sprache in einem Monat lernen?", "Wer würde eher bei einer Talentshow mitmachen?", "Wer würde eher seinen Job kündigen, um Influencer zu werden?", "Wer würde eher barfuß durch die Stadt laufen?", "Wer würde eher ein Geheimnis für sich behalten?", "Wer würde eher einen Streit anfangen?", "Wer würde eher zu spät zu seiner eigenen Hochzeit kommen?"
            ],
            'Peinlich': [
                "Wer würde eher in der Öffentlichkeit stolpern und hinfallen?", "Wer würde eher den Namen seines Dates vergessen?", "Wer würde eher mit Toilettenpapier am Schuh herumlaufen?", "Wer würde eher in einer Bibliothek laut lachen?", "Wer würde eher die falsche Person küssen?", "Wer würde eher eine peinliche Nachricht an die falsche Person schicken?", "Wer würde eher beim Essen etwas auf sein weißes Hemd kleckern?", "Wer würde eher im Kino laut schnarchen?", "Wer würde eher gegen eine Glastür laufen?", "Wer würde eher versuchen, eine automatische Tür aufzuschieben?", "Wer würde eher seinen Hosenstall offen lassen?", "Wer würde eher in einem wichtigen Meeting einen Lachanfall bekommen?", "Wer würde eher auf einer Party der Letzte sein, der geht?", "Wer würde eher ein schreckliches Geschenk machen?", "Wer würde eher im Supermarkt etwas fallen lassen und so tun, als wäre nichts passiert?", "Wer würde eher laut im Auto singen und an der Ampel erwischt werden?", "Wer würde eher mit dem Lehrer mit Vornamen reden?", "Wer würde eher im Restaurant das Essen zurückgehen lassen?", "Wer würde eher über seine eigenen Füße fallen?", "Wer würde eher die Pointe eines Witzes verderben?"
            ],
            'Party': [
                "Wer würde eher auf den Tischen tanzen?", "Wer würde eher als erstes einschlafen?", "Wer würde eher den DJ bestechen, ein schlechtes Lied zu spielen?", "Wer würde eher mit einer Pflanze reden?", "Wer würde eher eine Polonaise starten?", "Wer würde eher alle Getränke mixen und probieren?", "Wer würde eher am nächsten Morgen nichts mehr wissen?", "Wer würde eher Karaoke singen, obwohl er es nicht kann?", "Wer würde eher versuchen, mit dem Barkeeper zu flirten?", "Wer würde eher die Snacks alleine aufessen?", "Wer würde eher einen peinlichen Tanzmove auspacken?", "Wer würde eher mit dem Gastgeber über Politik diskutieren?", "Wer würde eher die Musik übernehmen und alle nerven?", "Wer würde eher heimlich gehen, ohne sich zu verabschieden?", "Wer würde eher ein Trinkspiel vorschlagen?", "Wer würde eher am nächsten Tag beim Aufräumen helfen?", "Wer würde eher eine Wette verlieren und etwas Dummes tun müssen?", "Wer würde eher Fotos von schlafenden Leuten machen?", "Wer würde eher eine Rede halten, obwohl niemand zuhört?", "Wer würde eher versuchen, einen Zaubertrick vorzuführen und scheitern?"
            ]
        };

        // --- APPLICATION STATE ---
        let app, auth, db, isFirebaseReady = false;
        let currentUser = null;
        let localPlayerName = '';
        let localPlayerAvatar = '👤'; // Default avatar
        let currentLobbyId = null;
        let gameUnsubscribe = null;
        let currentChart = null;
        let timerInterval = null;
        const gameDuration = 20000; // 20 seconds in milliseconds

        // --- UI ELEMENTS ---
        const screens = { name: document.getElementById('name-screen'), lobby: document.getElementById('lobby-screen'), game: document.getElementById('game-screen'), results: document.getElementById('results-screen') };
        const nameInput = document.getElementById('name-input');
        const lobbyCodeInput = document.getElementById('lobby-code-input');
        const createLobbyButton = document.getElementById('create-lobby-button');
        const joinLobbyButton = document.getElementById('join-lobby-button');
        const nameScreenButtons = [createLobbyButton, joinLobbyButton];
        const errorMessage = document.getElementById('error-message');
        const playerList = document.getElementById('player-list');
        const hostControls = document.getElementById('host-controls');
        const startGameButton = document.getElementById('start-game-button');
        const resetLobbyButton = document.getElementById('reset-lobby-button');
        const questionText = document.getElementById('question-text');
        const questionCounter = document.getElementById('question-counter');
        const voteOptions = document.getElementById('vote-options');
        const voteInfo = document.getElementById('vote-info');
        const waitingGif = document.getElementById('waiting-gif');
        const resultsQuestionText = document.getElementById('results-question-text');
        const resultsQuestionCounter = document.getElementById('results-question-counter');
        const resultsChartCanvas = document.getElementById('results-chart');
        const resultsHostControls = document.getElementById('results-host-controls');
        const nextQuestionButton = document.getElementById('next-question-button');
        const endGameButton = document.getElementById('end-game-button');
        const categorySelect = document.getElementById('category-select');
        const lobbyInfoForPlayers = document.getElementById('lobby-info-for-players');
        const resultsInfoForPlayers = document.getElementById('results-info-for-players');
        const timerCircle = document.getElementById('timer-circle');
        const timerText = document.getElementById('timer-text');
        const lobbyCodeDisplay = document.getElementById('lobby-code-display');
        const leaveLobbyButton = document.getElementById('leave-lobby-button');

        // UI Elements for Custom Questions
        const customQuestionSection = document.getElementById('custom-question-section');
        const customQuestionInput = document.getElementById('custom-question-input');
        const addCustomQuestionButton = document.getElementById('add-custom-question-button');
        const customQuestionsList = document.getElementById('custom-questions-list');

        // UI Element for Double Vote Joker
        const doubleVoteJokerButton = document.getElementById('double-vote-joker-button');

        // UI Element for Theme Toggle
        const themeToggleButton = document.getElementById('theme-toggle-button');

        // UI Elements for Avatar Selection
        const showAvatarPickerButton = document.getElementById('show-avatar-picker-button'); // New button
        const avatarPickerContainer = document.getElementById('avatar-picker-container'); // Container to toggle visibility
        const avatarSelectionDiv = document.getElementById('avatar-selection');
        const selectedAvatarDisplay = document.getElementById('selected-avatar');
        const EMOJIS = ['😀', '😎', '🥳', '🚀', '🌟', '👾', '🤖', '👻', '👽', '🐙', '🦖', '🦄', '🦊', '🐼', '🦁', '🦉', '🦋', '🌻', '🍕', '🎮', '⚽', '🎸', '🎨', '📚', '💻', '💡', '🏆', '🎉'];


        // --- FUNCTIONS ---

        /**
         * Switches the active screen in the UI.
         * @param {string} screenName - The ID of the screen to activate (e.g., 'name', 'lobby', 'game', 'results').
         */
        function switchScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            if (screens[screenName]) screens[screenName].classList.add('active');
        }

        /**
         * Populates the category selection dropdown with available question categories.
         * Includes the "Benutzerdefiniert" (Custom) option.
         */
        function populateCategories() {
            categorySelect.innerHTML = '';
            Object.keys(QUESTIONS).forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                categorySelect.appendChild(option);
            });
            // Add custom category option
            const customOption = document.createElement('option');
            customOption.value = 'Benutzerdefiniert';
            customOption.textContent = 'Benutzerdefiniert';
            categorySelect.appendChild(customOption);
        }
            
        /**
         * Generates a random 5-character uppercase lobby code.
         * @returns {string} The generated lobby code.
         */
        function generateLobbyCode() {
            return Math.random().toString(36).substring(2, 7).toUpperCase();
        }

        /**
         * Validates the player's name input.
         * @returns {boolean} True if the input is valid, false otherwise.
         */
        function validateInputs() {
            const name = nameInput.value.trim();
            if (name.length < 2 || name.length > 15) {
                errorMessage.textContent = 'Name muss zwischen 2 und 15 Zeichen lang sein.';
                return false;
            }
            localPlayerName = name;
            errorMessage.textContent = '';
            return true;
        }

        /**
         * Initializes Firebase and sets up anonymous authentication.
         */
        async function initializeGame() {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                onAuthStateChanged(auth, user => {
                    currentUser = user;
                    if (user) {
                        isFirebaseReady = true;
                        // Enable buttons only after Firebase is ready AND name is entered (handled by input listener)
                        nameInput.dispatchEvent(new Event('input')); 
                    } else {
                        signInAnonymously(auth).catch(error => {
                            console.error("Anonymous sign-in failed:", error);
                            errorMessage.textContent = "Verbindung zum Server fehlgeschlagen.";
                        });
                    }
                });
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                errorMessage.textContent = "Verbindung zum Server konnte nicht hergestellt werden.";
            }
        }

        /**
         * Handles updates to the game state from Firebase.
         * @param {DocumentSnapshot} docSnapshot - The snapshot of the lobby document.
         */
        function handleGameStateUpdate(docSnapshot) {
            if (!docSnapshot.exists()) {
                // Lobby was dissolved or doesn't exist anymore
                if (currentLobbyId) { // Only show alert if we were actually in a lobby
                    alert("Die Lobby wurde vom Host aufgelöst oder existiert nicht mehr.");
                }
                resetLocalState();
                return;
            }

            const gameState = docSnapshot.data();
            // Ensure players object exists and is iterable
            const players = gameState.players || {};
            const playerIds = Object.keys(players);
            const isHost = gameState.hostId === currentUser?.uid; // Check currentUser before accessing uid
            const isPlayerInGame = playerIds.includes(currentUser?.uid);

            // If a player is no longer in the lobby (e.g., removed by host or left)
            if (!isPlayerInGame && currentLobbyId && currentUser && currentUser.uid !== gameState.hostId) {
                resetLocalState();
                alert("Du bist nicht mehr in der Lobby.");
                return;
            } else if (!isPlayerInGame && currentUser?.uid === gameState.hostId && playerIds.length === 0) {
                 // Host is alone and somehow left, or lobby was dissolved
                 resetLocalState();
                 return;
            }


            currentLobbyId = docSnapshot.id;
            lobbyCodeDisplay.textContent = currentLobbyId;

            if (gameState.status === 'lobby') {
                switchScreen('lobby');
                renderPlayerList(players, gameState.hostId);
                hostControls.classList.toggle('hidden', !isHost);
                startGameButton.disabled = playerIds.length < 2; // Host can only start with at least 2 players
                categorySelect.value = gameState.currentCategory;
                lobbyInfoForPlayers.textContent = isHost ? (playerIds.length < 2 ? 'Warte auf mindestens einen weiteren Spieler...' : '') : `Der Host (${players[gameState.hostId]?.name || 'Unbekannt'}) startet das Spiel.`;
                
                // Show/hide custom question section for host based on selected category
                if (isHost && gameState.currentCategory === 'Benutzerdefiniert') {
                    customQuestionSection.classList.remove('hidden');
                    renderCustomQuestionsList(gameState.customQuestions || []);
                    // Enable/disable add custom question button based on input
                    customQuestionInput.dispatchEvent(new Event('input'));
                } else {
                    customQuestionSection.classList.add('hidden');
                }

            } else { // For 'playing', 'results', 'game_over' statuses

                if (gameState.status === 'playing') {
                    switchScreen('game');
                    // Use currentQuestions if available (shuffled questions), otherwise fall back to QUESTIONS
                    const categoryQuestions = (gameState.currentCategory === 'Benutzerdefiniert' ? gameState.customQuestions : QUESTIONS[gameState.currentCategory]) || [];
                    const totalQuestions = categoryQuestions.length;
                    const currentIndex = gameState.currentQuestionIndex;
                    const question = categoryQuestions[currentIndex] || "Keine Frage mehr in dieser Kategorie.";
                    
                    // Apply question fade-in animation
                    questionText.classList.remove('fade-in'); // Reset animation
                    questionText.textContent = question;
                    // Force reflow to ensure animation restarts
                    void questionText.offsetWidth;
                    questionText.classList.add('fade-in');
                    
                    renderVoteOptions(players, gameState.votes || {}); // Pass empty object if votes is null/undefined
                    updateTimer(gameState.timerStartedAt);
                    
                    const hasVoted = gameState.votes && gameState.votes[currentUser.uid];
                    waitingGif.classList.toggle('hidden', !hasVoted);

                    // Update Double Vote Joker Button state
                    const currentPlayerState = players[currentUser.uid];
                    if (currentPlayerState) {
                        doubleVoteJokerButton.classList.toggle('hidden', hasVoted || currentPlayerState.jokerUsedThisGame);
                        doubleVoteJokerButton.classList.toggle('joker-active', currentPlayerState.jokerActiveForNextVote);
                        doubleVoteJokerButton.disabled = hasVoted || currentPlayerState.jokerUsedThisGame || currentPlayerState.jokerActiveForNextVote;
                    } else {
                        doubleVoteJokerButton.classList.add('hidden'); // Hide if player state not found
                    }

                } else if (gameState.status === 'results') {
                    if (timerInterval) clearInterval(timerInterval);
                    switchScreen('results');
                    waitingGif.classList.add('hidden');
                    // Use currentQuestions if available (shuffled questions), otherwise fall back to QUESTIONS
                    const categoryQuestions = (gameState.currentCategory === 'Benutzerdefiniert' ? gameState.customQuestions : QUESTIONS[gameState.currentCategory]) || [];
                    const totalQuestions = categoryQuestions.length;
                    const currentIndex = gameState.currentQuestionIndex;
                    const question = categoryQuestions[currentIndex] || "Letzte Frage wurde ausgewertet.";

                    resultsQuestionCounter.textContent = `Frage ${currentIndex + 1} / ${totalQuestions}`;
                    resultsQuestionText.textContent = question;
                    renderResultsChart(players, gameState.votes || {});
                    resultsHostControls.classList.toggle('hidden', !isHost);
                    resultsInfoForPlayers.textContent = isHost ? '' : `Warte auf den Host für die nächste Runde...`;
                } else if (gameState.status === 'game_over') {
                    if (isHost) {
                        // Host initiates lobby dissolution after game over
                        dissolveLobby();
                    } else {
                        alert("Das Spiel ist beendet!");
                        resetLocalState();
                    }
                }
            }
        }

        /**
         * Renders the list of players in the lobby.
         * @param {Object} players - An object mapping player IDs to player names.
         * @param {string} hostId - The ID of the host player.
         */
        function renderPlayerList(players, hostId) {
            playerList.innerHTML = Object.entries(players).map(([id, p]) => 
                `<div class="p-2 bg-white rounded shadow-sm flex justify-between items-center dark:bg-gray-800 dark:text-gray-100">
                    <span class="flex items-center gap-2">
                        <span class="text-xl">${p.avatar || '👤'}</span> <!-- Display avatar -->
                        <span>${p.name}</span>
                    </span>
                    ${id === hostId ? '<span class="text-xs font-bold text-indigo-500 dark:text-indigo-400">HOST</span>' : ''}
                </div>`
            ).join('');
        }

        /**
         * Renders the voting options for the current question.
         * @param {Object} players - An object mapping player IDs to player names.
         * @param {Object} votes - An object mapping voter IDs to vote objects ({targetId: string, isDouble: boolean}).
         */
        function renderVoteOptions(players, votes) {
            voteOptions.innerHTML = '';
            const hasVoted = votes && votes[currentUser.uid];
            voteInfo.style.display = hasVoted ? 'block' : 'none';

            // Convert players object to an array for consistent iteration
            const playerArray = Object.entries(players);

            // Dynamically adjust grid columns based on number of players
            voteOptions.className = `w-full grid gap-3 mt-4 ${playerArray.length <= 2 ? 'grid-cols-1' : 'grid-cols-2'}`;

            playerArray.forEach(([playerId, playerData]) => {
                const button = document.createElement('button');
                button.textContent = playerData.name;
                button.dataset.voteFor = playerId;
                button.disabled = hasVoted; // Disable if already voted
                button.className = `p-3 rounded-lg font-semibold transition-transform transform ${
                    hasVoted ? 'bg-gray-300 text-gray-500 cursor-not-allowed dark:bg-gray-600 dark:text-gray-400' : 'bg-indigo-100 text-indigo-800 hover:bg-indigo-200 hover:scale-105 dark:bg-indigo-900 dark:text-indigo-200 dark:hover:bg-indigo-800'
                }`;
                button.addEventListener('click', handleVote);
                voteOptions.appendChild(button);
            });
        }

        /**
         * Renders the results of the current question as a pie chart.
         * @param {Object} players - An object mapping player IDs to player names.
         * @param {Object} votes - An object mapping voter IDs to vote objects ({targetId: string, isDouble: boolean}).
         */
        function renderResultsChart(players, votes) {
            const voteCounts = {};
            // Initialize vote counts for all players
            Object.values(players).forEach(p => voteCounts[p.name] = 0);

            // Count votes, considering double votes
            Object.values(votes).forEach(vote => {
                const votedForId = vote.targetId;
                const voteWeight = vote.isDouble ? 2 : 1;
                if (players[votedForId]) {
                    voteCounts[players[votedForId].name] += voteWeight;
                }
            });

            const labels = Object.keys(voteCounts);
            const data = Object.values(voteCounts);

            if (currentChart) currentChart.destroy();
            
            const textColor = document.documentElement.classList.contains('dark') ? '#d1d5db' : '#1F2937'; // Dynamic text color
            const borderColor = document.documentElement.classList.contains('dark') ? '#374151' : '#ffffff'; // Dynamic border color

            currentChart = new Chart(resultsChartCanvas, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Stimmen',
                        data: data,
                        backgroundColor: ['#818cf8', '#a78bfa', '#f472b6', '#fb923c', '#facc15', '#4ade80', '#2dd4bf', '#60a5fa'],
                        borderColor: borderColor,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: true,
                    plugins: {
                        legend: { position: 'top', labels: { color: textColor } },
                        tooltip: { callbacks: { label: ctx => `${ctx.label || ''}: ${ctx.parsed || 0} Stimme(n)` } }
                    }
                }
            });
        }
            
        /**
         * Sets the progress of the SVG timer circle.
         * @param {number} percent - The percentage of the circle to fill (0 to 1).
         */
        function setCircleProgress(percent) {
            const radius = timerCircle.r.baseVal.value;
            const circumference = radius * 2 * Math.PI;
            timerCircle.style.strokeDasharray = `${circumference} ${circumference}`;
            const offset = circumference - percent * circumference;
            timerCircle.style.strokeDashoffset = offset;
        }

        /**
         * Updates the countdown timer display and SVG circle.
         * @param {Timestamp} timerStartedAt - Firebase timestamp when the timer started.
         */
        function updateTimer(timerStartedAt) {
            if (timerInterval) clearInterval(timerInterval);
            if (!timerStartedAt) {
                timerText.textContent = '20';
                setCircleProgress(1); // Full circle
                return;
            }

            const startTime = timerStartedAt.toDate().getTime();

            timerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remainingSeconds = Math.max(0, Math.ceil((gameDuration - elapsed) / 1000));
                timerText.textContent = remainingSeconds;
                const progress = Math.max(0, (gameDuration - elapsed) / gameDuration);
                setCircleProgress(progress);
                if (elapsed >= gameDuration) {
                    clearInterval(timerInterval);
                    waitingGif.classList.add('hidden');
                }
            }, 100);
        }

        /**
         * Handles a player's vote for a question.
         * @param {Event} event - The click event from the vote button.
         */
        async function handleVote(event) {
            if (!isFirebaseReady || !currentUser || !currentLobbyId) return;
            const votedForId = event.target.dataset.voteFor;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);

            try {
                const gameDoc = await getDoc(gameDocRef);
                if (!gameDoc.exists()) return;
                const gameState = gameDoc.data();
                const currentPlayerState = gameState.players[currentUser.uid];

                if (!currentPlayerState) {
                    console.error("Current player state not found.");
                    return;
                }

                const isDoubleVote = currentPlayerState.jokerActiveForNextVote;

                const voteData = {
                    targetId: votedForId,
                    isDouble: isDoubleVote
                };

                // Update vote and joker status in a single batch for atomicity
                const updates = {
                    [`votes.${currentUser.uid}`]: voteData
                };

                if (isDoubleVote) {
                    updates[`players.${currentUser.uid}.jokerActiveForNextVote`] = false;
                    updates[`players.${currentUser.uid}.jokerUsedThisGame`] = true;
                }

                await updateDoc(gameDocRef, updates);

                // Add pulse animation to the clicked button
                event.target.classList.add('vote-button-pulse');
                setTimeout(() => {
                    event.target.classList.remove('vote-button-pulse');
                }, 300); // Match animation duration

            } catch (error) {
                console.error("Error casting vote:", error);
                errorMessage.textContent = "Fehler beim Abstimmen. Bitte versuche es erneut.";
            }
        }
            
        /**
         * Dissolves the current lobby (deletes it from Firebase). Only callable by host.
         */
        async function dissolveLobby() {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            try {
                // Before deleting, check if current user is indeed the host
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists() && docSnap.data().hostId === currentUser.uid) {
                    await deleteDoc(gameDocRef);
                    // handleGameStateUpdate will catch the !docSnapshot.exists() and reset state
                } else {
                    console.warn("Attempted to dissolve lobby without being the host or lobby not found.");
                    // If not host, just reset local state to leave the lobby
                    resetLocalState();
                }
            } catch(error) {
                console.error("Error dissolving lobby:", error);
                errorMessage.textContent = "Fehler beim Auflösen der Lobby.";
                resetLocalState(); // Attempt to reset even on error
            }
        }
            
        /**
         * Resets the local application state to the initial name input screen.
         * Clears any active subscriptions or intervals.
         */
        function resetLocalState() {
            if (gameUnsubscribe) {
                gameUnsubscribe();
                gameUnsubscribe = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            localPlayerName = '';
            localPlayerAvatar = '👤'; // Reset avatar to default
            selectedAvatarDisplay.textContent = localPlayerAvatar; // Update display
            // Remove selected-emoji class from all emojis
            avatarSelectionDiv.querySelectorAll('.selected-emoji').forEach(el => el.classList.remove('selected-emoji'));
            // Add selected-emoji class to the default avatar
            avatarSelectionDiv.querySelector(`span[data-emoji="${localPlayerAvatar}"]`)?.classList.add('selected-emoji'); // Use data-emoji for selection

            currentLobbyId = null;
            nameInput.value = '';
            lobbyCodeInput.value = '';
            errorMessage.textContent = '';
            waitingGif.classList.add('hidden');
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            customQuestionInput.value = ''; // Clear custom question input
            customQuestionsList.innerHTML = ''; // Clear custom questions list
            avatarPickerContainer.classList.add('hidden'); // Ensure avatar picker is hidden on reset
            switchScreen('name');
        }

        /**
         * Renders the list of custom questions for the host.
         * @param {string[]} questions - Array of custom questions.
         */
        function renderCustomQuestionsList(questions) {
            customQuestionsList.innerHTML = '';
            if (questions.length === 0) {
                customQuestionsList.textContent = 'Noch keine eigenen Fragen hinzugefügt.';
                return;
            }
            questions.forEach((q, index) => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center p-1 bg-white rounded shadow-sm dark:bg-gray-800 dark:text-gray-100';
                div.innerHTML = `
                    <span>${index + 1}. ${q}</span>
                    <button data-question="${q}" class="remove-question-button text-red-500 hover:text-red-700 text-lg">&times;</button>
                `;
                customQuestionsList.appendChild(div);
            });

            // Add event listeners for remove buttons
            customQuestionsList.querySelectorAll('.remove-question-button').forEach(button => {
                button.addEventListener('click', handleRemoveCustomQuestion);
            });
        }

        /**
         * Handles removing a custom question from the lobby.
         * @param {Event} event - The click event from the remove button.
         */
        async function handleRemoveCustomQuestion(event) {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const questionToRemove = event.target.dataset.question;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);

            try {
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists() && docSnap.data().hostId === currentUser.uid) {
                    await updateDoc(gameDocRef, {
                        customQuestions: arrayRemove(questionToRemove)
                    });
                } else {
                    console.warn("Attempted to remove question without being the host.");
                }
            } catch (error) {
                console.error("Error removing custom question:", error);
                errorMessage.textContent = "Fehler beim Entfernen der Frage.";
            }
        }

        /**
         * Populates the avatar selection grid and handles selection.
         */
        function populateAvatarSelection() {
            avatarSelectionDiv.innerHTML = '';
            EMOJIS.forEach(emoji => {
                const span = document.createElement('span');
                span.textContent = emoji;
                span.dataset.emoji = emoji; // Store emoji in a data attribute
                span.className = 'cursor-pointer text-2xl p-1 rounded-md hover:bg-indigo-100 dark:hover:bg-indigo-900 transition-colors flex items-center justify-center';
                
                if (emoji === localPlayerAvatar) {
                    span.classList.add('selected-emoji');
                }

                span.addEventListener('click', () => {
                    // Remove highlight from previously selected emoji
                    const currentlySelected = avatarSelectionDiv.querySelector('.selected-emoji');
                    if (currentlySelected) {
                        currentlySelected.classList.remove('selected-emoji');
                    }

                    localPlayerAvatar = emoji;
                    selectedAvatarDisplay.textContent = emoji;
                    span.classList.add('selected-emoji'); // Add highlight to newly selected
                });
                avatarSelectionDiv.appendChild(span);
            });
            selectedAvatarDisplay.textContent = localPlayerAvatar; // Ensure initial display is correct
        }


        // --- EVENT LISTENERS ---

        // Enable/disable buttons based on name input
        nameInput.addEventListener('input', () => {
            const nameIsValid = nameInput.value.trim().length >= 2 && nameInput.value.trim().length <= 15;
            createLobbyButton.disabled = !nameIsValid || !isFirebaseReady;
            joinLobbyButton.disabled = !nameIsValid || !isFirebaseReady; 
            if (!nameIsValid) {
                errorMessage.textContent = 'Name muss zwischen 2 und 15 Zeichen lang sein.';
            } else {
                errorMessage.textContent = '';
            }
        });

        createLobbyButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !validateInputs()) return;
            
            const newLobbyId = generateLobbyCode();
            currentLobbyId = newLobbyId;
            const gameDocRef = doc(db, "lobbies", newLobbyId);

            const newLobbyState = {
                hostId: currentUser.uid,
                status: 'lobby',
                players: { 
                    [currentUser.uid]: { 
                        name: localPlayerName,
                        avatar: localPlayerAvatar, // Add avatar to player state
                        jokerUsedThisGame: false, // Initialize joker status
                        jokerActiveForNextVote: false // Initialize joker status
                    } 
                },
                currentCategory: 'Standard',
                currentQuestionIndex: 0,
                votes: {},
                customQuestions: [], // Initialize custom questions array
                createdAt: serverTimestamp()
            };
            
            try {
                await setDoc(gameDocRef, newLobbyState);
                if (gameUnsubscribe) gameUnsubscribe();
                gameUnsubscribe = onSnapshot(gameDocRef, handleGameStateUpdate);
            } catch (error) {
                console.error("Error creating lobby:", error);
                errorMessage.textContent = "Fehler beim Erstellen der Lobby. Bitte versuche es erneut.";
            }
        });

        joinLobbyButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !validateInputs()) return;
            const lobbyId = lobbyCodeInput.value.trim().toUpperCase();
            if (!lobbyId) {
                errorMessage.textContent = "Bitte gib einen Lobby-Code ein.";
                return;
            }

            const gameDocRef = doc(db, "lobbies", lobbyId);
            try {
                const gameDoc = await getDoc(gameDocRef);
                if (!gameDoc.exists()) {
                    errorMessage.textContent = "Lobby nicht gefunden.";
                    return;
                }
                
                const gameState = gameDoc.data();
                // Check if lobby is full (e.g., max players 8, adjust as needed)
                if (Object.keys(gameState.players || {}).length >= 8) { // Example max players
                    errorMessage.textContent = "Lobby ist voll.";
                    return;
                }
                
                if (gameState.status !== 'lobby') {
                    errorMessage.textContent = "Diese Lobby ist nicht offen für neue Spieler.";
                    return;
                }

                currentLobbyId = lobbyId;
                const playerPath = `players.${currentUser.uid}`;
                // Add joker fields for joining player if they don't exist
                await updateDoc(gameDocRef, { 
                    [playerPath]: { 
                        name: localPlayerName,
                        avatar: localPlayerAvatar, // Add avatar to player state
                        jokerUsedThisGame: false,
                        jokerActiveForNextVote: false
                    } 
                });

                if (gameUnsubscribe) gameUnsubscribe();
                gameUnsubscribe = onSnapshot(gameDocRef, handleGameStateUpdate);

            } catch (error) {
                console.error("Error joining lobby:", error);
                errorMessage.textContent = "Fehler beim Beitreten zur Lobby. Stelle sicher, dass der Code korrekt ist.";
            }
        });
            
        leaveLobbyButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            
            try {
                const gameDoc = await getDoc(gameDocRef);
                if(gameDoc.exists()) {
                    if(gameDoc.data().hostId === currentUser.uid) {
                        // If host, dissolve the whole lobby
                        await dissolveLobby();
                    } else {
                        // If player, remove self from players list
                        const playerPath = `players.${currentUser.uid}`;
                        await updateDoc(gameDocRef, { [playerPath]: deleteField() });
                        resetLocalState(); // Reset local state immediately for players
                    }
                } else {
                    // Lobby already gone, just reset local state
                    resetLocalState();
                }
            } catch(error) {
                console.error("Error leaving lobby:", error);
                // Even if there's an error, try to reset locally
                resetLocalState();
            }
        });

        // --- HOST ACTIONS ---
        resetLobbyButton.addEventListener('click', dissolveLobby);

        startGameButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            const gameDoc = await getDoc(gameDocRef);
            
            if (!gameDoc.exists() || gameDoc.data().hostId !== currentUser.uid) {
                errorMessage.textContent = "Du bist nicht der Host dieser Lobby.";
                return;
            }

            const gameState = gameDoc.data();
            let questionsToUse;

            if (gameState.currentCategory === 'Benutzerdefiniert') {
                questionsToUse = gameState.customQuestions || [];
                if (questionsToUse.length === 0) {
                    alert("Die Kategorie 'Benutzerdefiniert' hat keine Fragen. Bitte füge Fragen hinzu oder wähle eine andere Kategorie.");
                    return;
                }
            } else {
                questionsToUse = QUESTIONS[gameState.currentCategory] || [];
                if (questionsToUse.length === 0) {
                    alert("Diese Kategorie hat keine Fragen. Bitte wähle eine andere.");
                    return;
                }
            }

            // Shuffle questions for a new game
            const shuffledQuestions = [...questionsToUse].sort(() => Math.random() - 0.5);

            // Reset joker status for all players at the start of a new game
            const playersToUpdate = {};
            for (const playerId in gameState.players) {
                playersToUpdate[`players.${playerId}.jokerUsedThisGame`] = false;
                playersToUpdate[`players.${playerId}.jokerActiveForNextVote`] = false;
            }

            await updateDoc(gameDocRef, {
                status: 'playing',
                currentQuestionIndex: 0,
                currentQuestions: shuffledQuestions, // Store shuffled questions
                votes: {},
                timerStartedAt: serverTimestamp(),
                ...playersToUpdate // Apply joker resets
            });
            
            // Auto-transition to results after gameDuration + small buffer
            setTimeout(async () => {
                const freshDoc = await getDoc(gameDocRef);
                // Only transition if still playing the same question and current user is host
                if (freshDoc.exists() && freshDoc.data().status === 'playing' && freshDoc.data().currentQuestionIndex === 0 && freshDoc.data().hostId === currentUser.uid) {
                        await updateDoc(gameDocRef, { status: 'results' });
                }
            }, gameDuration + 500); // 500ms buffer
        });
            
        categorySelect.addEventListener('change', async (e) => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const newCategory = e.target.value;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);

            const docSnap = await getDoc(gameDocRef);
            if (!docSnap.exists() || docSnap.data().hostId !== currentUser.uid) {
                errorMessage.textContent = "Nur der Host kann die Kategorie ändern.";
                return;
            }

            await updateDoc(gameDocRef, { currentCategory: newCategory });
        });
            
        nextQuestionButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            const gameDoc = await getDoc(gameDocRef);

            if (!gameDoc.exists() || gameDoc.data().hostId !== currentUser.uid) {
                errorMessage.textContent = "Du bist nicht der Host dieser Lobby.";
                return;
            }

            const gameState = gameDoc.data();
            const currentQuestions = gameState.currentQuestions || []; // Use shuffled questions
            const nextIndex = gameState.currentQuestionIndex + 1;

            // Reset jokerActiveForNextVote for all players for the next question
            const playersToUpdate = {};
            for (const playerId in gameState.players) {
                playersToUpdate[`players.${playerId}.jokerActiveForNextVote`] = false;
            }

            if (nextIndex >= currentQuestions.length) {
                await updateDoc(gameDocRef, { status: 'game_over', ...playersToUpdate });
            } else {
                await updateDoc(gameDocRef, {
                    status: 'playing',
                    currentQuestionIndex: nextIndex,
                    votes: {},
                    timerStartedAt: serverTimestamp(),
                    ...playersToUpdate // Apply jokerActiveForNextVote reset
                });
                
                // Auto-transition to results after gameDuration + small buffer
                setTimeout(async () => {
                    const freshDoc = await getDoc(gameDocRef);
                    // Only transition if still playing the same question and current user is host
                    if (freshDoc.exists() && freshDoc.data().status === 'playing' && freshDoc.data().currentQuestionIndex === nextIndex && freshDoc.data().hostId === currentUser.uid) {
                            await updateDoc(gameDocRef, { status: 'results' });
                    }
                }, gameDuration + 500); // 500ms buffer
            }
        });

        endGameButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            const docSnap = await getDoc(gameDocRef);

            if (!docSnap.exists() || docSnap.data().hostId !== currentUser.uid) {
                errorMessage.textContent = "Du bist nicht der Host dieser Lobby.";
                return;
            }
            await updateDoc(gameDocRef, { status: 'game_over' });
        });

        // --- CUSTOM QUESTION LOGIC ---
        customQuestionInput.addEventListener('input', () => {
            const questionText = customQuestionInput.value.trim();
            addCustomQuestionButton.disabled = questionText.length === 0 || questionText.length > 100;
        });

        addCustomQuestionButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;
            const questionText = customQuestionInput.value.trim();

            if (questionText.length === 0 || questionText.length > 100) {
                alert("Bitte gib eine Frage zwischen 1 und 100 Zeichen ein.");
                return;
            }

            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            try {
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists() && docSnap.data().hostId === currentUser.uid) {
                    await updateDoc(gameDocRef, {
                        customQuestions: arrayUnion(questionText)
                    });
                    customQuestionInput.value = ''; // Clear input after adding
                } else {
                    alert("Du bist nicht der Host dieser Lobby und kannst keine Fragen hinzufügen.");
                }
            } catch (error) {
                console.error("Error adding custom question:", error);
                alert("Fehler beim Hinzufügen der Frage. Bitte versuche es erneut.");
            }
        });

        // --- DOUBLE VOTE JOKER LOGIC ---
        doubleVoteJokerButton.addEventListener('click', async () => {
            if (!isFirebaseReady || !currentLobbyId || !currentUser) return;

            const gameDocRef = doc(db, "lobbies", currentLobbyId);
            try {
                const docSnap = await getDoc(gameDocRef);
                if (!docSnap.exists()) return;
                const gameState = docSnap.data();
                const currentPlayerState = gameState.players[currentUser.uid];

                if (!currentPlayerState) {
                    console.error("Current player state not found for joker activation.");
                    return;
                }

                if (currentPlayerState.jokerUsedThisGame) {
                    alert("Du hast deinen Joker für dieses Spiel bereits eingesetzt!");
                    return;
                }
                if (currentPlayerState.jokerActiveForNextVote) {
                    // Already active, perhaps toggle off? For now, just do nothing.
                    return;
                }
                
                // Activate joker for next vote
                await updateDoc(gameDocRef, {
                    [`players.${currentUser.uid}.jokerActiveForNextVote`]: true
                });

            } catch (error) {
                console.error("Error activating double vote joker:", error);
                errorMessage.textContent = "Fehler beim Aktivieren des Jokers. Bitte versuche es erneut.";
            }
        });

        // --- THEME TOGGLE LOGIC ---
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                themeToggleButton.textContent = '☀️'; // Sun icon for dark mode
            } else {
                document.documentElement.classList.remove('dark');
                themeToggleButton.textContent = '🌙'; // Moon icon for light mode
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        }

        // Apply theme on initial load
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            applyTheme(savedTheme);
        } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            // Default to system preference if no saved theme
            applyTheme('dark');
        } else {
            applyTheme('light'); // Default to light if no preference
        }

        themeToggleButton.addEventListener('click', toggleTheme);


        // --- INITIALIZATION ---
        populateCategories();
        populateAvatarSelection(); // Call this to set up the avatar selection
        initializeGame();

        // Event listener for the new show avatar picker button
        showAvatarPickerButton.addEventListener('click', () => {
            avatarPickerContainer.classList.toggle('hidden');
        });

    </script>
</body>
</html>
